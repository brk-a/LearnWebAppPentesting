# timing attack

#### what the code does
* checks if the data provided by a user
    * posseses a `token`
    * is the same as the `token` in `account` (an obj i, say, a db)
* user supplies data that specifys an account (any a/c)
* token is retrieved from user-supplied data
* check if token exists
    * yes: compare value with that of account
        * values are the same: return `true`
    * no: return `false`

#### what TF is a timing attack?

* consider the following

    ```js
    //snip
    if("foo"==="bar"){
        //do sth
    }
    //snip
    ```

* what happens when evaluating the `===` op?
    * iterate over each character of `foo` and `bar`
    * compare the chars at each index
    * if chars are the same return  `1` (or `true`), else `0` (or `false`)
    * if all indices return `1`, return `1`, else `0`
* in the example above, compare `f` to `b`; not the same, therefore, return 0. since we have already returned one `0`, return `0` overall; that is, `foo !== bar`
* consider the following

    ```js
    //snip
    if("abc"==="aaabc"){
        //do sth
    }
    //snip
    ```

* compare `a` to `a`; the same, therefore, return 1. compare `b` to `a`; not the same, therefore, return 0. since we have already returned one `0`, return `0` overall; that is, `abc !== aaabc`
* notice that it took one more step to return overall. that step is not free; it consumes processing ower and time
* consider the following

    ```js
    //snip
    if("abc"==="abc"){
        //do sth
    }
    //snip
    ```

* compare `a` to `a`; the same, therefore, return 1. compare `b` to `b`; the same, therefore, return 1. compare `c` to `c`; the same, therefore, return 1. return `1` overall; that is, `abc === abc`
* notice that it takes longer and longer to be able to return `1` overall. conversely, it takes less and less time to return `0` overall. we can use how quickly we return `0` to gauge ow long the char is, what the char is etc; in other words, we can use _brute force_. all we have to know is how long it took to get `1` overall. that, my friend, is the _timing attack_

#### the vulnerability
* timing attack

#### why it is vulnerable
* an attacker can guess a password if s.he has sufficient time and computing power; both are not difficult to attain

#### what now?
* simple; get rid of the `===` op
* use the module `crypto` from package `crypto` instead
* said package performs the `===` op w/o giving away info on how long it takes to return `1` (or, conversely, how long it took to return `0`)