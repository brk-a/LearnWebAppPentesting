# tokens
* flow
    - formats &rarr; how can a token be encoded? how do we read its contents? how do we validate it?
    - purpose &rarr; who is the token for? what is its intended use? where can it be sent?
    - type &rarr; how can token be transmitted? what ***"type"*** is a token?
### wtf is a token?
* [more info][def]
* a sequence of characters that are treated as a unit because they cannot be further broken down
1. ### formats
#### how tokens are encoded
* by value &rarr;
    - has all the values of the token w/i itself
    - can be validated by the receiver w/o making calls to a AS
    - may be encrypted or signed or both
    - examples: [JWTs][def4], [SAML][def3], [CWTs][def2]
* by reference &rarr; a reference (say, a pointer or symlink) to an entry on a DB
    - opaque to the holder
    - cannot be decrypted or decoded
    - requires call to the AS to read and validate
    - safer to use on the internet
2. ### purpose
#### who are tokens for?
* access token
    - meant to be sent to RS
    - that is, the access token is meant for the RS
    - client should never be able to decode access tokens because it is meant for the RS not the client
* refersh 
    - meant to sent to AS directly from client when the client requires to perform a refresh
    - that is, the refresh token is meant for the AS
* ID token (OpenID Connect)
    - is received after the code flow is completed
    - meant for the client and client only
3. ### type
#### how can tokens be used?
* bearer token
    - the token equivalent of cash
    - can be used by anyone
    - sender is not verified
        - needs to be protected; keep safe and secret
        - do not log; anyone can use said token when they read your logs
        - do not keep on browser
        - send over TLS or other encrypted channel
    - examples: OAuth, cookies
        - caveat: examples named above require HTTPS/TLS but must be treated as stated above that
* holder of key (HoK)
    - aka proof of possession (PoP)
    - aka sender-constrained tokens
    - token equivalent of a credit/debit card
    - sender must present proof of ownership
    - cannot be sent by other parties
    - tokens are constrained  to sender
        - one cannot use it even when they pick it up in, say, a log
        - you need the secret bound to that token to use it (same as a PIN in a chip-n-pin card)
    - examples: [DPoP][def5], [mutual TLS][def6]
#### using an access token
* send in the authorisation header
* user the keyword `Bearer` or `DPoP` depending on the one you use
* make no assumption about the structure or format of the token
    - could be JWT or something else
    - `DPoP` tokens require the sender's proof-of-ownership token in the header
    - be ready for anything
* example 1: `Bearer`

    ```text
        GET /fnapi/users
        Host: api.fnapi.co.ke:8080
        Authorization: Bearer _0XBPWQQ_960d35fc-27d33-46db-96ee
    ```

* example 2: `DPoP`

    ```text
        GET /fnapi/users
        Host: api.fnapi.co.ke:8080
        Authorization: DPoP _0XBPWQQ_960d35fc-27d33-46db-96ee
        DPoP: eyJ0eXAi...4UCbQ
    ```

#### JWTs
* JWT is not a protocol; it can be used in various ways depending on the protocol being implemented
* JWT is a format; one way among many to encode data into a token
* [more info][def7]
* used for many purposes
    - ID tokens are ***always*** JWTs
    - access tokens ***can*** be JWTs
    - refresh tokens are ***never*** be JWTs
* almost always signed [JWS][def8]
* may be encrypted [JWE][def9]
* example

    ```text
        eyJraWQiOiItMzgwMTIzNDU2IiwieDV0IjoiTVItYUJDRGVmZ0hJSktMIiwiYWxnIjoiSFMyNTYiLCJ0eXAiOiJKV1QifQ.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkYgTmpha2FpIiwiaWF0IjoxNTE2MjM5MDIyfQ.ddL0qkRqqKtsZyDfM_eVNPUHpJ76kYMW3FCUPHjD5v4
    ```
* there are three parts (seperated by dots)
    - header has details about the token, say, the hashing algo used. the

        ```json
            {
            "kid": "-380123456",
            "x5t": "MR-aBCDefgHIJKL",
            "alg": "HS256",
            "typ": "JWT"
            }
        ```

    - payload is the actual content of the 
    
        ```json
            {
            "sub": "1234567890",
            "name": "F Njakai",
            "iat": 1516239022
            }
        ```

    - signature, well, signs the other parts; it changes whenthe contents of the header and/or payload change, therefore, this is a way to find out if the token is tampered with

        ```text
            HMACSHA256(
            base64UrlEncode(header) + "." +
            base64UrlEncode(payload),
            "my-very-secure-256-bit-secret"
            )
        ```

* 

[def]: https://www.geeksforgeeks.org/token-patterns-and-lexems/
[def2]: https://www.rfc-editor.org/rfc/rfc8392
[def3]: https://en.wikipedia.org/wiki/SAML_2.0
[def4]: https://en.wikipedia.org/wiki/JSON_Web_Token
[def5]: https://oauth.net/2/dpop/
[def6]: https://www.cloudflare.com/learning/access-management/what-is-mutual-tls/
[def7]: https://en.wikipedia.org/wiki/JSON_Web_Token
[def8]: https://en.wikipedia.org/wiki/JSON_Web_Signature
[def9]: https://en.wikipedia.org/wiki/JSON_Web_Encryption