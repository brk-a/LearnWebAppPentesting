# pillars of API security
* TLDR: three pillars
    1. governance
    2. monitoring
    3. testing
### 1. governance
* idea is to define, establish and enforce processes of developing, testing and getting API into production in a consistent and secure way
##### awareness
* know your APIs
    - how are APIs developed?
    - how are they deployed?
    - how are they tested?
    - who owns said API?
    - what about documentation?
    - are APIs reusable?
    - etc
* know your data
* know your risks
    - identify APIs data, access paths etc (potential threats)
    - assess vulterabilities, logic flaws, access controls 3<sup>rd</sup> party risk
    - determine/estimate the likelihood and probability of an attack
    - understand the potential damage, loss and/or consequences of an attack
    - develop a plan to address said risks
##### policies and processes
* engineering process
* API documentation
    - OpenAPI specification etc
* design guidelines
    - authentication: type (basic, token, certificate), how to implement
    - authorisation: who has access to what, where to enforce
    - naming conventions: URIs as nouns, methods as verbs, pluralisation,heirarchy, case, language, no jargon/abbr
    - error codes: status codes, reference IDs, human-readable messages
    - when to increment, when not to, types of versions
    - units, formats, standards: date/time formats, TZs etc
##### documentation: OpenAPI specification (aka swagger)
* not optional
* industry standard for REST APIs
* machine-readable (YAML, JSON)
* facilitates development and 3<sup>rd</sup> party integration
* facilitates security testing
* can be manually or automatically generated
* tells developers how to control the public and private parts of the API
* requires old documentatio to be retired (because it is a great threat vector)
* defines API capability
    - title, description version
    - base URL
    - end-points/paths
    - request and response payloads
    - authentication requirements
    - parameters, data types
    - methods
##### benefits
* consistency
* setting, managing and achieving expectations for your engineering team
    - what is required? 
    - what are the documentation requirements?
    - authentication policies, versioning etc
* establishing a standard process for how APIs move from development into production 
* enforcing security
    -  nothing moves into production that has not gone through security assessment and vetting
### 2. monitoring
* idea is to have your APIs perform as expected and be free of vulnerabilities or other flaws
* runtime protection
    - policy enforcement
    - authentication
    - traffic filtering
* threat detection
    - fraudulent traffic
    - distributed attacks
    - incident response
* control validation
    - verify API controls
    - uncover anomalies
##### approaches to monitoring
* proactive
    - API gateway
    - web app firewall
* reactive
    - logging, SIEM
    - runtime API threat management
##### APi discovery
* monitoring compliments API inventory efforts
    - identify API endpoints that are in use
    - discover undocumented/unknown APIs
* comprehensive discovery requires more sources
    - API gateway, web app firewall
    - code repository
    - app testing, crawling
* reliance on traffic-based discovery misses
    - internal API traffic not seen by traffic analysis tool
    - pre-production APIs
    - unexercised endpoints
##### limitations of monitoring
* difficult to get full visibility
    - requires sensors on every network segment
* high false-positive rate
    - live traffic contains limited context
    - difficult to identify data access violations in real-time
    - API monitoring tools are, typically, used as alerts not to actively stop threats
* SaaS-based monitoring requires sharing traffic w. 3<sup>rd</sup> parties
    - privacy concerns
    - bandwidth requirements
* traffic-blocking solutions may add latency to the system
### 3.  testing
* idea is to have  your APIs behaving as expected; there are no attacks in process that are succeeding or other anomalous behaviour on your APIs during runtime
* you want to find vulnerabilities in pre-production, not production
* *standard playbook* test categories have limited value
    - XSS, injection,  buffer overflow
    - important to run said tests to avois bot-based attacks
    - API breaches rarely exploit these
    - major breaches are, typically, business logic flaws

    ```mermaid
    ---
    title: need for API-first testing
    ---
        flowchart LR
        subgraph app
        A((web app))
        B((mobile app))
        end
        C[pen test, web scan]-->app
        D[app]<-->E((API))
        F[attacker]-->|bypasses app| E
        E<-->F((BE))
    ```

*  application testing has, historically, focused on the UI layer; web or mobile app
* attackers, however, simply go around the apps to the API itself. see [0-real_world_api_breaches][def]

> &quot; Web or API flaws are getting missed by the standard tests. It's not injections that are
> causing these breaches. It's lack of authentication. It's lack of authorisation. It's
> vulnerabilities like that that are exposing data in vast quantities from, from sites. It's
> not really an abuse of the UI layer. It's an abuse of the API layer &quot;
>  \- Corey  Ball

##### API testing categories
1. API security
    - unsecured endpoints
    - authentication exploits
    - enumeration
    - app DoS, rate limiting
    - missing TLS; SSL issues
    - injection, fuzzing
    - SSRF
    - server property leaks
2. data security
    - access control
    - excess data exposure
    - sensitive data exposure
    - personal, health, bank data etc
    - file and/or directory exposure
    - encryption at rest
    - data exfiltration
3. business logic
    - cross-account access
    - API function abuse
    - role-based access control
    - pen-testing


[def]: ./0-real_world_api_breaches.md