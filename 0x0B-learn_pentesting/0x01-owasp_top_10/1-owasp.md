# API1:2023 broken object-level authorisation (BOLA)
* BOLA vulnerabilities occur when an API provider does not have sufficient controls to enforce authorisation
    - in other words, API users should only have access to sensitive resources that belong to them
    - an attacker is able to access the sensitive data of other users when BOLA is present
### OWASP attack vector description
* attackers can exploit API endpoints that are vulnerable to BOLA by manipulating the ID of an object that is sent within the request
* object IDs can be sequential integers, UUIDs, generic strings etc
* regardless of the data type, they are easy to identify in the request target (path or query string parameters), request headers or even as part of the request payload
### OWASP security weakness description
* this has been the most common attack and has had the most impact on APIs so far
* authorisation and access control mechanisms in modern applications are complex and widespread
* developers may forget to use checks before accessing a sensitive object even if the application implements a proper infrastructure for authorisation checks
* access control detection is not, typically, amenable to automated static or dynamic testing
### OWASP impacts description
* unauthorised access may result in data disclosure to unauthorised parties, data loss or data manipulation
* unauthorised access to objects may also lead to full account takeover
### OWASP preventative measures
* TL;DR: implement robust authorisation controls. said controls must consider user policies and role-based access control hierarchies. primary focus must be to ensure that authenticated users only have access to resources they are authorised to have access to. use less predictable resource IDs; this decreases the probability of success of a user or attacker who is guessing the resource IDs of other users. developers must perform tests that specifically test authorisation controls 

* implement a proper authorisation mechanism that relies on the user policies and hierarchy
* use said authorisation mechanism to check if the logged-in user has access to perform the requested action on the record in every function that uses an input from the client to access a record in the database
* prefer the use of random and unpredictable values as GUIDs for records' IDs to other forms of IDs
* write tests to evaluate the vulnerability of the authorisation mechanism; do not deploy changes that make the tests fail

### more ...
* an API endpoint that does not have sufficient access controls will not perform checks to make sure users can only access their own resources
* user A is able to obtain user B’s resources via API requests when said controls are missing
* APIs use a value, say, names or numbers to identify various objects
* when an attacker will attempt to obtain the resources when unauthenticated or authenticated as a different user when s/he discovers an API's resource IDs
* Example: an authenticated user, Bethel, sends a `GET` request to `https://herohospital.com/api/v3/users?id=2727` and receives the following response:

    ```json
        {
        "id": "2727",
        "fname": "Bethel",
        "lname": "Faye",
        "dob": "1995-02-19",
        "username": "bfaye",
        "diagnosis": "ADHD",
        }
    ```
    
    - this is alright; Bethel should be able to access Bethel's own information, however, if Bethel is able to access another user’s information then a BOLA vulnerability is present
    - a weakness can be tested by using other resource IDs in place of 2727
    - say Bethel is able to obtain information about another user by sending `https://herohospital.com/api/v3/users?id=2728` and receives the following response:

    ```json
        {
        "id": "2728",
        "fname": "Tihitna",
        "lname": "Sisa",
        "dob": "1999-03-30",
        "username": "tsisa",
        "diagnosis": "Dissociative Identity Disorder",
        }
    ```

    - assuming that Bethel is still using her authorisation to access this data, this is a clear indication that the API is vulnerable to BOLA
* BOLA is not always as simple as the example above because there is flexibility in how resources are provisioned and requested from one API to the next
* below are a few examples of how different resources may be accessed via API requests
    - the bold resource IDs in the following API requests should catch your attention

    GET /api/user/**1**
    GET /user/account/find?**user_id=aE1230000token**
    POST /company/account/**Apple**/balance
    GET /admin/settings/account/**bfaye**

    - in these instances, you can, most likely, alter the bold values to get other resources

    GET /api/resource/**3**
    GET /user/account/find?**user_id=23**
    POST /company/account/**Google**/balance
    POST /admin/settings/account/**tsisa**

* of course, in `POST` requests, the resource could also be requested in the `POST` body
    - if a user, A, can successfully access the information of any other user then there is a vulnerability
    - BOLA vulnerabilities are the most common API vulnerability, are easily exploitable and require a low amount of technical skills to discover
* more ways of implementing BOLA

    |type|valid request|BOLA request|
    |:---|:---|:---|
    |predictable ID|GET /api/v1/account/2222 Token: UserA_token|GET /api/v1/account/6785 Token: UserA_token|
    |ID combination|GET /api/v1/userA/data/2222 Token: UserA_token|GET /api/v1/userB/data/4539 Token: UserA_token|
    |integer as ID|POST /api/v1/account/ Token: UserA_token {"Account": 2222}|POST /api/v1/account/ Token: UserA_token {"Account": [1234]}|
    |email as user ID|POST /api/v1/account/ Token: UserA_token {"email": "userA@email.co.ke"}|POST /api/v1/account/ Token: UserA_token {"email": "userB@email.com"}|
    |group ID|GET /api/v1/group/CompanyA Token: UserA_token|GET /api/v1/group/CompanyB Token: UserA_token|
    |group and user combination|POST /api/v1/group/CompanyA Token: UserA_token {"email": "userA@companyA.co.ke"}|POST /api/v1/group/CompanyB Token: UserA_token {"email": "userA@companyB.co.ke"}
    |nested object|POST /api/v1/user/checking Token: UserA_token {"Account": 2222}|POST /api/v1/user/checking Token: UserA_token {"Account": {"Account": 2345}}|
    |multiple objects|POST /api/v1/user/checking Token: UserA_token {"Account": 2222}|POST /api/v1/user/checking Token: UserA_token {"Account": 2222, "Account": 2345, "Account": 8765}|
    |predictable token|POST /api/v1/account/ Token: UserA_token {"data": "DflK1df7jSdfa1acaa"}|POST /api/v1/account/ Token: UserA_token {"data": "DflK1df7jSdfa2dfaa"}|
