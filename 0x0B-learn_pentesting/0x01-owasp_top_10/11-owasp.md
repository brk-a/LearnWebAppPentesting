# beyond top 10: injection
* injection vulnerabilities place when an attacker is able to send commands that are executed by the systems that support the web application
* the most common forms of injection attacks are: SQL injection, Cross-site scripting (XSS) and operating system command injection
* APIs are, simply, another attack vector for these critical attacks to be communicated from an attacker to the supporting databases and systems
### OWSP 2019 attack vector description
* attackers feed the API with malicious data through whatever injection vectors are available (e.g., direct input, parameters, integrated services etc.) and expect it to be sent to an interpreter
### OWASP 2019 impacts description
* injection leads to information disclosure and data loss
* it may also lead to DoS or complete host takeover
### OWASP 2019 preventative measures
* preventing injection requires keeping data separate from commands and queries viz:
    - perform data validation using a single, trustworthy and actively maintained library
    - validate, filter and sanitise all client-provided data or other data coming from integrated systems
    - special characters should be escaped using the specific syntax for the target interpreter
    - prefer a safe API that provides a parameterised interface
    - always limit the number of returned records to prevent mass disclosure in case of injection
    - validate incoming data using sufficient filters to only allow valid values for each input parameter
    - define data types and strict patterns for all string parameters

### more ...
* injection flaws exist when a request is passed to the API’s supporting infrastructure w/o the API provider filtering the input to remove unwanted characters (a process known as input sanitisation)
    - the infrastructure may treat data from the request as code and run it
    - an attacker will be able to conduct injection attacks like SQL injection, NoSQL injection and system command injection when this sort of flaw is present
* in each of these injection attacks, the API delivers an unsanitised payload directly to the operating system running the application or its database
    - an attacker sends a payload containing SQL commands to a vulnerable API that uses a SQL database when this sort of flaw is present; said API passes the commands to the database which processes and performs the commands
    - same case with vulnerable NoSQL databases and affected systems
* verbose error messaging, HTTP response codes and unexpected API behaviour can all be clues to an attacker
    - it is an indication to the attacker that they have discovered an injection flaw
    - say, for example, an attacker were to send `OR 1=0--` as an address in an account registration process. the API may pass that payload directly to the backend SQL database where the `OR 1=0` statement fails (as 1 does not equal 0) and causes some SQL error viz:

        ```text
            POST /api/v1/register HTTP 1.1

            Host: example.com

            --snip--

            {
            “Fname”: “Goat”,
            “Lname”: “Matata”,
            “Address”: “' OR 1=0--”,
            }
        ```

* an error in the backend database may show up as a response to the consumer
    - in this case, the attacker may receive a response, say, 
    
        ```text
            “Error: You have an error in your SQL syntax…”
        ```
    
    - any response directly from databases or the supporting system will serve as a clear indicator that there is likely an injection vulnerability
* injection vulnerabilities are often complemented by other weaknesses for example poor input sanitisation
* injection flaws can have serious impacts by providing an attacker with the ability to manipulate an API’s supporting system or database
* finding injection flaws requires diligently testing API endpoints, paying attention to how the API responds and crafting requests that attempt to manipulate the backend systems
* injection attacks have been around for decades; there are many standard security controls that can be used to protect API providers from them