# types of API documentation
* three high level things that you see in API documentation:
    1. reference material; the encyclopedia of how to go use an API. devs understand the ideas and are ready to go write code references when they understand the API
    2. what-is material; the concepts underlying the API. what, in simple terms, does this API do? what are the big things that you are trying to accomplish? what is the job that you are trying to do?
    3. how-to material; how to accomplish certain tasks or achieve certain results. you may want to showcase certain steps that users need to take in order to accomplish something
### walkthrough using PagerDuty
* escalation policies define which users should be alerted at which time
* a non developer that  browses PagerDuty's site says, *"is this something that we should be using?"*
* now, in this case, I am being contrived because PagerDuty is a developer centric product as a whole, however, let us imagine for a moment that I am shopping as a non technical user; I will get a sense of what this thing does
* this is, typically, a topical and functional description of what this does. we may dig into the concepts behind this and in this case, PagerDuty expressly calls out an API concepts document
* the other part is the anatomy of API reference material
* now, there are certainly lots of other things out there, however, we are going to talk about REST-style APIs
    - request-response cycle etc
    - you will notice that PagerDuty's docs have responses and status codes REST style: 200 is good, 400 means the user did something wrong, 5xx errors mean that something is wrong on the server etc
* from a developer's perspective this is what we are looking for. what is the information that comes back? I need every field described in adequate enough fashion that I know what that field means
    - say `offset` and `limit` were not described. most developers would guess this is probably pagination. same case with `total`, however, as we get into the escalation policies, `summary` in this case has a specific meaning: a short form, server generated string, succinct and important information
    - `summary` not something that someone has curated; it is a server-generated value. this has insight built into it: I understand that there is going to be something interesting and valuable in that summary information
- say we went down the list of all of these properties. there are things to learn at every step. keep in mind that when you are looking at the fields returned in the body of a response, the field name itself will often have incredible ambiguity
    - example: the `summary` in escalation policies. what does `summary` mean? the word itself is an ambiguous term; it is used in a lot of domains, therefore, we need a precise definition of what `summary` is in order for it to have adequate context
    - it is as if we are looking at it backwards: look at the response first. for what it is worth, this is what people quite often want to see first, after all, I want to know what am I going to get in the response before I do all the work to make a request. does said response have the data that I need?
    - if we shift over to that request side you will notice security is a constraint/parameter: in this case it is an API key. there is probably a set of steps to go get that. it is an important and critical first step to making any request. *"is there some kind of security being passed here?"* is the question you ask yourself
    - beyond that are the query parameters. you may see headers as well. it is going to depend on what kind of endpoint you are calling: whether it is a `GET`, `PUT` `POST` or `DELETE`. you are going to see different kind of interaction patterns here. you will notice a lot of things with `offset`, `limit`, `total` etc are paging controls
* consistency: look at all of PagerDuty's APIs: you will see the same paging parameters and paging response parameters as a consistent pattern
    - therefore, if I write code as a client against this API, I can reuse how paging works against the PagerDuty API across many APIs and not have to write a bespoke way of doing it every time I integrate with another operation
* headers: except in `Content-Type`, headers are about content negotiation. in PagerDuty's case, they say that they are using a specific media type that is bespoke to PagerDuty: `+JSON`
    - this tells me it is going to be JSON data. they are telling me that `application/vnd.pagerduty` is their specific domain description of what is going to JSON
    - `Content-Type` is, simply, part of content negotiation: inthis case `application/json`
    - it is highly likely that you are only going to see `application/json`-type content in APIs, however, always be mindful that there could be other content types supported. on older stuff, you may see XML. in specific domains, you could see very specific media types to that domain, say, `vcf` for contact information
    - be mindful that developers may have multiple ways or multiple formats to retrieve data from one API
* versioning: how are you handling versioning? in PagerDuty's case, they are passing it as part of a media type in the `Accept` header and making it an implied part of their content negotiation
* status codes: documentation is the first thing that a developer looks at to learn how to use an API before they form their first request
    - it is likely that their first interaction with that API is going to produce an error because they do not know how to use it and maybe they have made mistakes in how they formed that request
    - it is essential that we describe what happens in the case that the response is not 2xx: 200 class responses are success. 400 classes (4xx) mean you (the API builder) did something wrong and 500 classes (5xx) mean the server did something wrong
    - for a client, a 400 class error tells you there is probably something wrong with the way that you provided those parameter values; you must fix that in order to get a valid response
    - the shape of that error: say I am using an API from PagerDuty. I am going to write error handling-code with the expectation that all the other APIs they offer follow the same standard, therefore, I should be able to reuse that error handling code more or less. that saves me a lot of code as a client because I will not duplicate effort and/or code
    - from a documentation perspective, it is critical that you focus a lot of energy early on and what are the errors going to look like both in their shape and in their content
    - in this case, we are simply showing the shape but it certainly is common that you may have a breakdown of what kind of errors are you going to get
    - this often digs beyond just the status code: under each error object that is returned in the response is a message. said message tells the human what is wrong
    - there is quite often a code that is accompanied with it. this goes a level deeper than just those HTTP status codes and goes into an application specific error code. reference material that enumerates what those error codes mean helps users debug etc
    - provide a link back to the documentation. at the very least, in your documentation, always have some place to go look up those error codes and understand in general what our error is going to look like on your platform
* beyond the customer facing API, we should pay to their first interaction with errors the  mere practice of documenting what the error is about
* the discipline of documenting those things shows implicit quality and security enhancement
* a typical feature that you will see in API documentation is a `Try it!`-type component where you can go get some sort of authorisation token, fill in the parameters, click the  `send API request` button and see what the response looks like
    - now, in some cases, this may have a sandbox environment or sort of a mock interface that gives you fake information, however, it should give you quick tactile feedback on what is this going to look like
    - this gives you a no-code way to try an API and for developers quite often as a way to quickly get a quick test of what it is they are thinking
    - there may also be a request sample, say, cURL. there could be language-specific code examples here: something that one can copy, paste into their application and use as a starting point to make that call. this combination significantly reduces the error rate that new users are going to experience
    - this is not explicitly a feature of how you write your documentation, however, it is a feature that people expect to see in developer portals at large especially with APIs
* back to PagerDuty's API's listing of escalation policies: they have a link to read about these concepts
    - this is a snippet from their documentation of what that looks like
    - said list of escalation policies gives you a list of existing escalation policies: an escalation policy keeps track of who gets the notification
    - in the `concepts` document we get a comprehensive description of what this means
    - say this is an internally-focused API; you may also see accompanying links and material on how this is implemented on the backend or what other systems it relies on to make this work
    - a new user may not get it at first try. you want them to be able to get a deeper definition of what that concept is. you will notice, in this case, there are many references that link to other reference materials
    - someone that consumes APIs from your platform will not be able to accomplish their task by calling one API; they will call a group of related APIs in order to build a full interaction, therefore, you need these overviews to describe how these concepts relate to each other and how they are tied together in fulfilling certain workflows
* the `how do we get started?` section of API docs:  this should be the first thing that any new user who looks for your APIs and comes up on that first page
    - they should immediately be taken down an enumerated set of steps: here is what I need to do to call these APIs (*these APIs* because, best case scenario, there few ways to call a lot of different APIs). if there is one way to provide access win-win for everyone: from a consumption standpoint, I have one way to do things
    - from a security standpoint you will notice that step one in this example is to switch to `Stripe API`. this is probably one of the strongest examples over the last 10 years or so of excellent API documentation; excellent developer experience. in the `Stripe API` every call to a Stripe API must include an API secret key. it then goes on to very briefly describe, here is what you need to do to get these API keys
    - notice it does not say: *"if you are calling this API, do it this way. if you are calling this other API, do it that way."*
    - one consistent method of authentication is key here both in terms of usability and having a single method of accessing these things so that you can really focus your effort on securing one area