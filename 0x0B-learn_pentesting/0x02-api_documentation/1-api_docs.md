# types of API documentation
* three high level things that you see in API documentation:
    1. reference material; the encyclopedia of how to go use an API. devs understand the ideas and are ready to go write code references when they understand the API
    2. what-is material; the concepts underlying the API. what, in simple terms, does this API do? what are the big things that you are trying to accomplish? what is the job that you are trying to do?
    3. how-to material; how to accomplish certain tasks or achieve certain results. you may want to showcase certain steps that users need to take in order to accomplish something
### walkthrough using PagerDuty
* escalation policies define which users should be alerted at which time
* a non developer that  browses PagerDuty's site says, *"is this something that we should be using?"*
* now, in this case, I am being contrived because PagerDuty is a developer centric product as a whole, however, let us imagine for a moment that I am shopping as a non technical user; I will get a sense of what this thing does
* this is, typically, a topical and functional description of what this does. we may dig into the concepts behind this and in this case, PagerDuty expressly calls out an API concepts document
* the other part is the anatomy of API reference material
* now, there are certainly lots of other things out there, however, we are going to talk about REST-style APIs
    - request-response cycle etc
    - you will notice that PagerDuty's docs have responses and status codes REST style: 200 is good, 400 means the user did something wrong, 5xx errors mean that something is wrong on the server etc
* from a developer's perspective this is what we are looking for. what is the information that comes back? I need every field described in adequate enough fashion that I know what that field means
    - say `offset` and `limit` were not described. most developers would guess this is probably pagination. same case with `total`, however, as we get into the escalation policies, `summary` in this case has a specific meaning: a short form, server generated string, succinct and important information
    - `summary` not something that someone has curated; it is a server-generated value. this has insight built into it: I understand that there is going to be something interesting and valuable in that summary information
- say we went down the list of all of these properties. there are things to learn at every step. keep in mind that when you are looking at the fields returned in the body of a response, the field name itself will often have incredible ambiguity
    - example: the `summary` in escalation policies. what does `summary` mean? the word itself is an ambiguous term; it is used in a lot of domains, therefore, we need a precise definition of what `summary` is in order for it to have adequate context
    - it is as if we are looking at it backwards: look at the response first. for what it is worth, this is what people quite often want to see first, after all, I want to know what am I going to get in the response before I do all the work to make a request. does said response have the data that I need?
    - if we shift over to that request side you will notice security is a constraint/parameter: in this case it is an API key. there is probably a set of steps to go get that. it is an important and critical first step to making any request. *"is there some kind of security being passed here?"* is the question you ask yourself
    - beyond that are the query parameters. you may see headers as well. it is going to depend on what kind of endpoint you are calling: whether it is a `GET`, `PUT` `POST` or `DELETE`. you are going to see different kind of interaction patterns here. you will notice a lot of things with `offset`, `limit`, `total` etc are paging controls
* consistency: look at all of PagerDuty's APIs: you will see the same paging parameters and paging response parameters as a consistent pattern
    - therefore, if I write code as a client against this API, I can reuse how paging works against the PagerDuty API across many APIs and not have to write a bespoke way of doing it every time I integrate with another operation
* headers: except in `Content-Type`, headers are about content negotiation. in PagerDuty's case, they say that they are using a specific media type that is bespoke to PagerDuty: `+JSON`
    - this tells me it is going to be JSON data. they are telling me that `application/vnd.pagerduty` is their specific domain description of what is going to JSON
    - `Content-Type` is, simply, part of content negotiation: inthis case `application/json`
    - it is highly likely that you are only going to see `application/json`-type content in APIs, however, always be mindful that there could be other content types supported. on older stuff, you may see XML. in specific domains, you could see very specific media types to that domain, say, `vcf` for contact information
    - be mindful that developers may have multiple ways or multiple formats to retrieve data from one API
* versioning: how are you handling versioning? in PagerDuty's case, they are passing it as part of a media type in the `Accept` header and making it an implied part of their content negotiation
* status codes: documentation is the first thing that a developer looks at to learn how to use an API before they form their first request
    - it is likely that their first interaction with that API is going to produce an error because they do not know how to use it and maybe they have made mistakes in how they formed that request
    - it is essential that we describe what happens in the case that the response is not 2xx: 200 class responses are success. 400 classes (4xx) mean you (the API builder) did something wrong and 500 classes (5xx) mean the server did something wrong
    - for a client, a 400 class error tells you there is probably something wrong with the way that you provided those parameter values; you must fix that in order to get a valid response
    - the shape of that error: say I am using an API from PagerDuty. I am going to write error handling-code with the expectation that all the other APIs they offer follow the same standard, therefore, I should be able to reuse that error handling code more or less. that saves me a lot of code as a client because I will not duplicate effort and/or code
    - from a documentation perspective, it is critical that you focus a lot of energy early on and what are the errors going to look like both in their shape and in their content
    - in this case, we are simply showing the shape but it certainly is common that you may have a breakdown of what kind of errors are you going to get
    - this often digs beyond just the status code: under each error object that is returned in the response is a message. said message tells the human what is wrong
    - there is quite often a code that is accompanied with it. this goes a level deeper than just those HTTP status codes and goes into an application specific error code. reference material that enumerates what those error codes mean helps users debug etc
    - provide a link back to the documentation. at the very least, in your documentation, always have some place to go look up those error codes and understand in general what our error is going to look like on your platform
* beyond the customer facing API, we should pay to their first interaction with errors the  mere practice of documenting what the error is about
* the discipline of documenting those things shows implicit quality and security enhancement
* a typical feature that you will see in API documentation is a `Try it!`-type component where you can go get some sort of authorisation token, fill in the parameters, click the  `send API request` button and see what the response looks like
    - now, in some cases, this may have a sandbox environment or sort of a mock interface that gives you fake information, however, it should give you quick tactile feedback on what is this going to look like
    - this gives you a no-code way to try an API and for developers quite often as a way to quickly get a quick test of what it is they are thinking
    - there may also be a request sample, say, cURL. there could be language-specific code examples here: something that one can copy, paste into their application and use as a starting point to make that call. this combination significantly reduces the error rate that new users are going to experience
    - this is not explicitly a feature of how you write your documentation, however, it is a feature that people expect to see in developer portals at large especially with APIs

Coming back to, I promised before  we would we highlighted where in PagerDuty's API about listing escalation policies, that they had a link to read about these concepts. And this is a snippet from their documentation of what that looks like. Now before we got two lines that said, the list escalation policies gives you a list of existing escalation policies. And an escalation policy keeps track of who gets the notification . Whatever it was, two simple sentences. However, in the concepts document we get a pretty comprehensive description of what this means and I will not read through it all here, but I think it is a great example of where if you've got a simple functional description at the top of the reference documentation for an operation, that may link back to a more comprehensive description.

And internally, if this is an internal focused API, you may also see accompanying links and material on how this is implemented on the backend or what other systems it relies on to make this work .

For a new user, when they look at those couple of sentences, that quick paragraph view, I still do not get it. You want them to be able to jump in and get a deeper definition of what something means. And you will notice in this case, there is many references that link to other reference material. Right at the top: User, Schedule, Notified, Incident, Services. All of those are other concepts and likely other API operations.

And this is to say that quite often, someone that is consuming APIs from your platform is not going to be able to accomplish their task by calling one API. They will call a group of related things in order to build a full interaction . So sometimes you need these overviews to describe how these concepts relate to each other and how they are tied together in fulfilling certain workflows.

Although we will come back to that more workflow oriented view, it is important not only to describe beyond the simple paragraph and have the bigger concepts, but also what concepts does this relate to or depend on.

 The most important concept in I think all documentation, but it is exceptionally true in API documentation is how do we get started? This should be the first thing that any new user who looks for your APIs and comes up on that first page. They should immediately be taken down an enumerated set of steps. Here is what I need to do to call these APIs. And I say these APIs intentionally to say that it hopefully is not a lot of different ways to call a lot of different APIs. If there is one way to provide access, that is a win for everyone. From a consumption standpoint, I have one way to do things .

From a security standpoint you will notice right off the bat, the step one and in this example, we switch gears to the Stripe API, which I think is, probably one of the strongest examples over the last 10 years or so of excellent API documentation, excellent developer experience. And step one in the Stripe API, every call to a Stripe API must include an API secret key. And then it goes on to very briefly describe, here's what you need to do to get these API keys.

And notice it doesn't say, if you are calling this API, do it this way. If you are calling this other API, do it that way. One consistent method of auth is key here, both in terms of usability and having a single method of accessing these things so that you can really focus your effort on securing one area.

So these steps should lead me down a road of, at the end of a few steps and hopefully this is not more than four or five steps , I've made a successful API call. that is really the goal that you are getting to. And in many API programs, this is actually an instrumented thing in that we want to look at, what is the time to first "hello world"? How long does it take to get through those first steps and make the first call? And a common benchmark is to say, this should take no more than five minutes.

Now from a documentation standpoint this is where we take heart and make it look easy, right? And in some ways we have to really bench test what we are thinking about on how people are going to use this. And really simplify and really whittle things down to be easy for a new user to adopt.

So most important concept, this is where you should be putting a ton of effort. I know I said the errors were the first place to start, but that is in reference. This is more in concepts. So just super key. Especially because step one is almost always how to do auth. And, as the old adage goes, if you are running a two day hackathon, day one is getting auth done. This is quite often the inconvenient, difficult, tricky part. And if you are building an API and documenting it, this is your riskiest part.

So you should have a crystal clear, succinct understanding of how this works for everybody. Preferably one way to do it for all APIs. So that you comprehend how it works and that you can explain it succinctly. If you cannot do that, you probably shouldn't be publishing it. you are probably taking risks.

And our final topic Tasks. Again, we will look at Stripe. And I said concepts and tasks can be a bit of a fuzzy line. But I think the way I think of this is, it is really, what is the workflow that you are trying to accomplish here and what is it that you are trying to do? So I often refer to this as like a showcase.

So in Stripe's case, right there, top left, they are saying, all right, do you want to start an integration? And they are starting with a conceptual idea, payment links, checkout, web elements, that is going to take you down the road of learning some concepts and learning how to do those things together.

This is really important in the API world because, if you launch something out there with say reference material only. No concepts. No workflow driven tasks. People will do serendipitous things. They will come up with very creative ways to use your API. That it is in some cases you didn't plan for and just do not work.

So in some ways this is also projecting to end users this is what this API was meant to do. This is the job that it will do for you. And keeping that frame of mind for new users will guide them into using it in the way that you intended. And hopefully not creating friction or problems for themselves or for you.

Not listed in kind of the big three and this is because it is not pervasively common. In some ways it is a cost prohibitive concept for many programs. But it is definitely a key to large scale success, is that if you want quick adoption and you want API consumers to connect quickly, do not make them write too much code. And you can do that by providing SDKs, client libraries, tooling around the API. That means you do not write code to call it explicitly. You may call a library, you may use a command line interface. Things like this.

And I say these can be cost prohibitive, especially in the startup world or in smaller companies. Building and maintaining client libraries can be a very costly effort. But you will notice in PagerDuty's case, PagerDuty didn't go build libraries to interact with its API for all languages. In fact, many of these came from the PagerDuty community.

So you will notice there is a warning on here too, Community Support. PagerDuty doesn't endorse or provide technical support, so on. This, in some ways, is how a lot of folks make this an affordable approach. But from a documentation standpoint, it is also an opportunity for you to showcase where there could be community options out there that you didn't build that ultimately are going to provide a better experience, faster onboarding, all that sort of stuff. With the caveat that, this is not stuff we built and so thereby we cannot really directly support it. you are going to have to work with the community on it.

But at any rate, it is an optional fourth column that in more mature programs you will tend to see. This is also very applicable for internal API programs as you reach a larger scale, a larger quantity of APIs. It is definitely a speed accelerant to have more of these kind of client libraries, command line tools, so on