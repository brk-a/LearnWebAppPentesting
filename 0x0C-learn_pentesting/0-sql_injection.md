# SQLi (SQLi)
### flow
* what SQLi is
* how to find and exploit SQLi vulnerabilities
* how to prevent SQLi
### what SQLi is
* a web security vulnerability that allows an attacker to interfere with the queries that an application makes to its database
* can allow an attacker to view data that they are not normally able to retrieve
* this may include data that belongs to other users or any other data that the application can access
* in many cases, an attacker can modify or delete this data, therefore, cause persistent changes to the application's content or behaviour
* in some situations, an attacker can escalate a SQLi attack to compromise the underlying server or other back-end infrastructure
* can also enable them to perform denial-of-service attacks
### impact of a  successful SQLi attack
* successful SQLi attacks may result in unauthorised access to sensitive data such as:
    * passwords
    * credit card details
    * personal user information
* reputational damage
* regulatory fines
* an attacker can obtain a persistent backdoor into an organisation's systems leading to a long-term compromise that can go unnoticed for a long period
### how to detect SQLi vulnerabilities
* option one: manually using a systematic set of tests against every entry point in the application. to do this, you would typically submit:
    - the single quote character `'` and look for errors or other anomalies
    - some SQL-specific syntax that evaluates to the base (original) value of the entry point and to a different value then look for systematic differences in the application responses
    - boolean conditions such as `OR 1=1` and `OR 1=2` and look for differences in the application's responses
    - payloads designed to trigger time delays when executed within a SQL query and look for differences in the time taken to respond
    - OAST payloads designed to trigger an out-of-band network interaction when executed within a SQL query and monitor any resulting interactions

* option two: find the majority of SQLi vulnerabilities quickly and reliably using [Burp Scanner][def]
### SQLi in different parts of the quesry
* most SQLi vulnerabilities occur within the `WHERE` clause of a `SELECT` query
* most experienced testers are familiar with this type of SQLi
* however, SQLi vulnerabilities can occur at any location within the query and within different query types. some other common locations where SQLi arises are:
    * in `UPDATE` statements within the updated values or the `WHERE` clause
    * in `INSERT` statements within the inserted values
    * in `SELECT` statements within the table or column name
    * in `SELECT` statements within the `ORDER BY` clause
### examples of SQLi
* common ones include:
    - retrieving hidden data: you modify a SQL query to return additional results
    - subverting application logic: you can change a query to interfere with the application's logic
    - `UNION` attacks: you can retrieve data from different database tables
    - blind SQLi: the results of a query you control are not returned in the application's responses
##### 1. retrieving hidden data
* picture a shopping application that displays products in different categories. say a user clicks on the `Gifts` category; their browser requests the URL: `https://insecure-website.com/products?category=Gifts`
* the application makes a SQL query to retrieve details of the relevant products from the database:

    ```sql
        SELECT * FROM products WHERE category = 'Gifts' AND released = 1
    ```

* said SQL query asks the database to return:
    - all details (*)
    - from the `products` table
    - where the category is `Gifts`
    - and `released` is 1.
* restriction `released = 1` is used to hide products that are not released; we could assume for unreleased products `released` = 0
* the application does not implement any defences against SQLi attacks; this means an attacker can construct an attack, for example:   `https://insecure-website.com/products?category=Gifts'--`
* this results in the SQL query:

    ```sql
        SELECT * FROM products WHERE category = 'Gifts'--' AND released = 1
    ```

* note that `--` is a comment indicator in SQL; this means that the rest of the query is interpreted as a comment effectively removing it
* in this example, this means the query no longer includes `AND released = 1`, therefore, all products are displayed including those that are not yet released
* you can use a similar attack to cause the application to display all the products in any category including categories that they don't know about: `https://insecure-website.com/products?category=Gifts'+OR+1=1--`
* this results in the SQL query:

    ```sql
        SELECT * FROM products WHERE category = 'Gifts' OR 1=1--' AND released = 1
    ```

* the modified query returns all items where either the category is `Gifts` or 1 is equal to 1; `1=1` is true always, therefore, the query returns all items 
##### 2. subverting application logic
* assume an application that lets users log in with a username and password. if a user submits the username `wiener` and the password `bluecheese`, the application checks the credentials by performing the following SQL query:

    ```sql
        SELECT * FROM users WHERE username = 'wiener' AND password = 'bluecheese'
    ```

* if the query returns the details of a user then the login is successful, otherwise, it is rejected
* in this case, an attacker can log in as any user without the need for a password. they can do this using the SQL comment sequence `--` to remove the password check from the `WHERE` clause of the query
* for example: submit the username `administrator'--` and a blank password results in the following query:

    ```sql
        SELECT * FROM users WHERE username = 'administrator'--' AND password = ''
    ```

* this query returns the user whose username is administrator and successfully logs the attacker in as that user
##### 3. retrieving data from other database tables
* in cases where the application responds with the results of a SQL query, an attacker can use a SQLi vulnerability to retrieve data from other tables within the database
* you can use the `UNION` keyword to execute an additional `SELECT` query and append the results to the original query
* for example: an application executes the following query containing the user input `Gifts`:

    ```sql
        SELECT name, description FROM products WHERE category = 'Gifts'
    ```

* an attacker can submit the input `' UNION SELECT username, password FROM users--`
* this causes the application to return all usernames and passwords along with the names and descriptions of products

    ```sql
        SELECT name, description FROM products WHERE category = 'Gifts' UNION SELECT username, password FROM users--
    ```

##### 4. blind SQLi vulnerabilities
* many instances of SQLi are blind vulnerabilities
* this means that the application does not return the results of the SQL query or the details of any database errors within its responses
* blind vulnerabilities can still be exploited to access unauthorised data, however, the techniques involved are generally more complicated and difficult to perform
* the following techniques can be used to exploit blind SQLi vulnerabilities depending on the nature of the vulnerability and the database involved:
    * change the logic of the query to trigger a detectable difference in the application's response depending on the truth of a single condition. this might involve injecting a new condition into some boolean logic or conditionally triggering an error such as a divide-by-zero
    * conditionally trigger a time delay in the processing of the query. this enables you to infer the truth of the condition based on the time that the application takes to respond
    * you can trigger an out-of-band network interaction using OAST techniques. this technique is very powerful and works in situations where the other techniques do not
    * directly exfiltrate data via the out-of-band channel. for example, place the data into a DNS lookup for a domain that you control
##### 5. second-order SQLi
* first-order SQLi occurs when the application processes user input from a `HTTP` request and incorporates the input into a SQL query in an unsafe way
* second-order SQLi occurs when the application takes user input from a `HTTP` request and stores it for future use
* this is usually done by placing the input into a database but no vulnerability occurs at the point where the data is stored
* later, when handling a different `HTTP` request, the application retrieves the stored data and incorporates it into a SQL query in an unsafe way
* for this reason, second-order SQLi is also known as stored SQLi
* second-order SQLi often occurs in situations where developers are aware of SQLi vulnerabilities and so safely handle the initial placement of the input into the database
* once the data is later processed, it is deemed to be safe since it was previously placed into the database safely. At this point, the data is handled in an unsafe way because the developer wrongly deems it to be trusted
##### 6. examining the database
* some core features of SQL are implemented in the same way across popular database platforms, therefore, many ways of detecting and exploiting SQLi vulnerabilities work identically on different types of database
* however, there are also many differences between common databases; these means that some techniques for detecting and exploiting SQLi work differently on different platforms. for example:
    * syntax for string concatenation
    * comments
    * batched (or stacked) queries
    * platform-specific APIs
    * error messages
* once you identify a SQLi vulnerability, it is often useful to obtain information about the database. this information can help you to exploit the vulnerability
* you can query the version details for the database. different methods work for different database types
* this means that if you find a particular method that works, you can infer the database type. for example, on Oracle you can execute:

    ```sql
        SELECT * FROM v$version
    ```

* you can also identify what database tables exist and the columns they contain. for example, on most databases you can execute the following query to list the tables:
    
    ```sql
        SELECT * FROM information_schema.tables
    ```

### SQLi in different contexts
* one can use the query string to inject a malicious SQL payload, however, one can perform SQLi attacks using any controllable input that is processed as a SQL query by the application
* for example, some websites take input in JSON or XML format and use this to query the database
* these different formats may provide different ways for you to obfuscate attacks that are otherwise blocked due to WAFs and other defense mechanisms
* weak implementations often look for common SQLi keywords within the request so you may be able to bypass these filters by encoding or escaping characters in the prohibited keywords
* for example, the following XML-based SQLi uses an XML escape sequence to encode the `S` character in `SELECT`:

    ```xml
        <stockCheck>
            <productId>123</productId>
            <storeId>999 &#x53;ELECT * FROM information_schema.tables</storeId>
        </stockCheck>
    ```

* this will be decoded server-side before being passed to the SQL interpreter
### how to prevent SQLi
* you can prevent most instances of SQLi using parameterised queries instead of string concatenation within the query. said parameterised queries are also know as ***"prepared statements"***.
* the following code is vulnerable to SQLi because the user input is concatenated directly into the query:

    ```java
        String query = "SELECT * FROM products WHERE category = '"+ input + "'";
        Statement statement = connection.createStatement();
        ResultSet resultSet = statement.executeQuery(query);
    ```

* you can rewrite this code in a way that prevents the user input from interfering with the query structure:

    ```java
        PreparedStatement statement = connection.prepareStatement("SELECT * FROM products WHERE category = ?");
        statement.setString(1, input);
        ResultSet resultSet = statement.executeQuery();
    ```

* you can use parameterised queries for any situation where untrusted input appears as data within the query including the `WHERE` clause and values in an `INSERT` or `UPDATE` statement
* they cannot be used to handle untrusted input in other parts of the query such as table or column names or the `ORDER BY` clause
* application functionality that places untrusted data into these parts of the query needs to take a different approach, such as:
    * whitelisting permitted input values
    * using different logic to deliver the required behaviour
* for a parameterised query to be effective in preventing SQLi, the string that is used in the query must always be a hard-coded constant
* it must never contain any variable data from any origin; do not be tempted to decide case-by-case whether an item of data is trusted and continue using string concatenation within the query for cases that are considered safe
* it is easy to make mistakes about the possible origin of data or for changes in other code to taint trusted data

[def]: https://portswigger.net/burp/vulnerability-scanner