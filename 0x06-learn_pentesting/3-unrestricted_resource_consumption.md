# unrestricted resource consumption

#### API specific
#### Business specific
#### Exploitability: average
#### Prevalence: widespread
#### Detectability: easy
#### Technical: severe


### threat agents/attack vectors
* exploitation requires simple API requests
* multiple concurrent requests are performed from a single local computer or through cloud computing resources
* most of the automated tools available are designed to cause DoS via high loads of traffic; this impacts APIs’ service rate

### security weakness
* it is common to find APIs that do not limit client interactions or resource consumption * * crafted API requests, such as those that include parameters that control the number of resources to be returned and perform response status/time/length analysis, should allow identification of the issue
* case applies to batched operations; although threat agents do not have visibility over costs impact, they can infer said costs based on service providers’ (e.g. cloud provider) business/pricing model
* source of vuln
    * missing and/or inappropriate settings
        * execution timeout(s)
        * max allocable memory
        * max #file descriptors
        * max #processes
        * max upload file size
        * #ops in a single requests
        * #records in a single request
        * 3rd-party provider's spend limit
* every API request has a technical and financial cost
* lack of rate controls increase the chances of
    * DoS
    * DDoS
    * unnecessary financial cost (tech-side->servers, load balancers etc; corporate-side->bad PR, low reputation, fewer customers, small top line and bottom line etc)
    * poor service to legitimate users

### impact
* exploitation can lead to DoS due to resource starvation; can also lead to operational costs increase such as those related to the infrastructure due to higher CPU demand, increasing cloud storage needs etc

### example


### how To prevent
* use a solution that makes it easy to limit memory, CPU, number of restarts, file descriptors and processes such as containers / serverless code (e.g. lambdas)
* define and enforce a maximum size of data on all incoming parameters and payloads such as maximum length for strings, maximum number of elements in arrays and maximum upload file size (regardless of whether it is stored locally or in cloud storage)
* implement a limit on how often a client can interact with the API within a defined timeframe (rate limiting)
* rate limiting should be fine-tuned based on the business needs. some API endpoints might require stricter policies
* limit/throttle how many times or how often a single API client/user can execute a single operation (e.g. validate an OTP or request password recovery without visiting the one-time URL)
* add proper server-side validation for query string and request body parameters, specifically, the one that controls the number of records to be returned in the response
* configure spending limits for all service providers/API integrations. when setting spending limits is not possible, billing alerts should be configured instead