# Cookie Collection & Reverse Engineering

* idea is to see how session management through cookie collection works
* also see how to reverse-engineer said cookies after analysing them
* environment: Firefox ESR (with `Cookie Editor` extension) on Kali Linux
* punching bag: OWASP Juice Shop
* a HTTP cookie is a small block of data created by a web server while a user is browsing a website
* is placed on the user's device (or other device eg ISP server) used to access said website by the user's web browser
* more than one cookie may be placed on a user's device during a session
* three types of cookies
    1. session. a server-specific cookie that cannot be passed to any machine other than the one that generated the cookie. allows the browser to re-identify itself to the single, unique server to which the client had previously authenticated. are temporary; used to maintain information about a user's activity during a single browsing session. the authentication token in the cookie contains a lot of the user's \[personal\] information 
    2. permanent. data files that provides websites with user preferences, settings and information for future visits. are stored on a user's device. are used to store information that can be accessed across multiple browsing sessions
    3. third-party. come from third party servers and/or APIs that are in the request-response chain. that is, they are placed on a website by someone other than the website being visited. are also called tracking cookies or targeting cookies
* in an auth scenario (login-perform actions-logout), there are at least three cookies: the cookie that authenticates the user, the cookie that authorises the user and the cookie that tracks whether the user is logged in or not; here is where cookie collection comes in

### JWT crash course
* [JSON Web Token](https://jwt.io/introduction)
* an open standard that defines a compact and self-contained way to securely transmit information between parties. said info is transmitted as a JSON object
* JWT is a standard; all JWTs are tokens but not all tokens are JWTs
* can be sent through a URL, through a POST parameter, or inside an HTTP header because of its relatively small size
* contains all the required information about an entity to avoid querying a database more than once
* recipient of a JWT also does not need to call a server to validate the token
* why JWTs?
    * compact. JSON is less verbose than XML; when it is encoded, a JWT is smaller than a SAML token. this makes JWT a good choice to be passed in HTML and HTTP environments
    * more secure than SAML.JWTs use a public/private key pair in the form of an X.509 certificate for signing. a JWT is also symmetrically signed by a shared secret using the HMAC algorithm. while SAML tokens can use public/private key pairs like JWT, signing XML with XML Digital Signature without introducing obscure security holes is quite difficult compared to the simplicity of signing JSON
    * common/ readilly available. JSON parsers are common in most programming languages because they map directly to objects. conversely, XML does not have a natural document-to-object mapping. this makes it easier to work with JWT than SAML assertions
    * easy to process. WT is used at internet scale; it is easier to process on users' devices, especially mobile
* where are JWTs used?
    * authentication. an ID token is returned when a user successfully logs in using their credentials; said token is always a JWT
    * authorisation. once a user is successfully logged in, an application may request to access routes, services, or resources (e.g. APIs) on behalf of that user. to do so, in every request, it must pass an _Access Token_, which may be in the form of a JWT. Single Sign-on (SSO) widely uses JWT because of the small overhead of the format, and its ability to easily be used across different domains
    * information exchange. JWTs are a good way of securely transmitting information between parties because they can be signed, which means you can be certain that the senders are who they say they are;  the structure of a JWT allows you to verify that the content hasn't been tampered with
* security features of JWTs
    * JWTs are signed using a secret (using the HMAC algorithm) or a public/private key pair using RSA or ECDSA. tokens that  are signed using public/private key pairs use the signature to certify that only the party holding the private key signed the JWT
* structure of a JWT
    * here is an example of an encoded JWT

    ~~~javascript
    eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
    ~~~

    * notice there are three base64-URL strings separated by dots 
        1. header. contains the type of token (in this case, a JWT) and the hashing algorithm used (in this case, HMAC-SHA256). here is the decoded form of the header from the encoded JWT above

        ~~~json
        {
            "typ": "JWT",
            "alg": "HS256"
        }
        ~~~

        2. payload. contains the information to be transmitted. here is the decoded form of the header from the encoded JWT above

        ~~~json
        {
            "sub": "1234567890",
            "name": "John Doe",
            "iat": 1516239022
        }
        ~~~

        3. signature. used to verify the message was not changed along the way and, in the case of tokens signed with a private key, verify that the sender of the JWT is who it says it is. to create a signature, take the encoded header, the encoded payload, a secret, the algorithm specified in the header then sign them. the secred can be plaintext or encoded in base64; the one in the token above is in plaintext. here is the decoded form of the signature from the encoded JWT above

        ~~~javascript
        HMACSHA256(
            base64UrlEncode(header) + "." +
            base64UrlEncode(payload),
            "your-256-bit-secret"
        ) 
        ~~~

### how to collect cookies
* fire up Juice Box
* fire up `Cookie Editor` on the browser
* go to developer tools (CTRL-SHIFT-I or CMD-SHIFT-I)
* click `Storage`
    * you should see some cookies: _cookieconsent\_status_ and _io_
* click `Cookie Editor` right next to `Storage`
* in Juice Box, create an account and log in
* inspect the element again (the developer tools step)
* click `Cookie Editor`
    * notice there are three cookies now: _cookieconsent\_status_ , _io_ and _token_
* click `token`
    * there will be a long string; that is an encoded JWT
    * it may/may not contain vulnerabilities; there is only one way to know
* copy the string
* paste it in the `Encoded` input field of this [JWT decoder](https://jwt.io/)
* see what the decoder says
    * decode shows the header, payload and signature
    * in the header, the hashing algo is RS256 [RSA 256][def3]
    * the payload is interesting: email is in plaintext and password is encoded
    * can the password be decoded? yes, of course
        * copy the encoded password string
        * in your browser, go the [online MD5 decryptor][def2]
        * paste the string in the input field and click `Decrypt`
        * if the string was MD5-encrypted, you should have your password in plain text. if not, try [crackstation][def]
    * the signature is invalid; this means we can manipulate it and break authentication

[def]: https://crackstation.net/crackstation-wordlist-password-cracking-dictionary.htm
[def2]: https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&ved=2ahUKEwiM6cvrjuD-AhXggv0HHfVGACoQFnoECAwQAQ&url=https%3A%2F%2Fmd5online.org%2Fmd5-decrypt.html&usg=AOvVaw2f-SO8ruMEJtwa_aFTaPx9
[def3]: https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&cad=rja&uact=8&ved=2ahUKEwi3k8qWjuD-AhUai_0HHatMCZ0QFnoECC8QAQ&url=https%3A%2F%2Fwww.techtarget.com%2Fsearchsecurity%2Fdefinition%2FRSA&usg=AOvVaw1PAlci14K3zg80GQ5B2I0h